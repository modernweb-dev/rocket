ğŸš¨ Feature Alert ğŸš¨

Rocket improves the way it handles web components ğŸ‰

â¡ï¸ maintain a list of available tag names and it's imports
â¡ï¸ automatically injects imports as needed
â¡ï¸ enables progressive hydration ğŸ’ª

How does it work? ğŸ‘‡

---

First, we start by creating a very simple web component

We call it `hello-wave` and it has some static HTML & CSS

ğŸ‘‰ `site/src/components/HelloWave.js`

```js
import { LitElement, html, css } from 'lit';

export class HelloWave extends LitElement {
  render() {
    return html`<h2>Hello ğŸ‘‹</h2>`;
  }

  static styles = css`
    h2 {
      color: #e03131;
    }
  `;
}
```

---

We then add it to the rocket components object in the format of
'tag-name': 'bare-import::ClassName'

â¡ï¸ It needs to be a bare import as we do not know in which file it will be imported
â¡ï¸ A separating entrypoint for each class allows us to load them individually

ğŸ‘‰ `data/pages/recursive.data.js`

```js
export const components = {
  'hello-wave': 'my-pkg/site/src/components/HelloWave.js::HelloWave',
};
```

---

Now we can start using the component on our pages.

â¡ï¸ Save our file
â¡ï¸ Component Registration gets injected
â¡ï¸ Component gets server rendered to Declarative Shadow DOM

PS: adding component registration to the page had was inspired by a discussion with @fcamblor ğŸ™‡â€â™‚ï¸

ğŸ‘‰ `site/pages/index.rocket.js`

```js
export default () => html`
  <h2>Hello World</h2>
  <hello-wave></hello-wave>
`;
```

```js
/* START - Rocket auto generated - do not touch */
export const sourceRelativeFilePath = 'index.rocket.js';
import { html, components, layout } from './recursive.data.js';
export { html, components, layout };
export async function registerCustomElements() {
  // server-only components
  // prettier-ignore
  customElements.define('hello-wave', await import('my-pkg/site/src/components/HelloWave.js').then(m => m.HelloWave));
}
/* END - Rocket auto generated - do not touch */

export default () => html`
  <h1>Hello World</h1>
  <hello-wave></hello-wave>
`;
```

```html
<h2>Hello World</h2>
<hello-wave>
  <template shadowroot="open">
    <style>
      h2 {
        color: #e03131;
      }
    </style>
    <!--lit-part 18Qb0exw8us=-->
    <h2>Hello ğŸ‘‹</h2>
    <!--/lit-part-->
  </template>
</hello-wave>
```

![Hello Wave Static](./wave-static.png)

---

Thats it! ğŸ‰

For components that only require styles and no interactivity we are done.

â¡ï¸ The HTML output works without any JavaScript
â¡ï¸ It's crystal clear which components are used on the page
â¡ï¸ You do not need to hand write the imports

So are we done? ğŸ¤”

---

Actually - this is where the fun starts ğŸ‰

Let's add a more interactive element
âœï¸ a type writer effect
ğŸ”¼ with a counter ğŸ¤¯

ğŸ‘‰ `site/src/components/HelloTyper.js`

```js
import { LitElement, html, css } from 'lit';

let i = 0;
const fullText = [...'to this wonderful world of progressive hydration ğŸ¤¯'];

export class HelloTyper extends LitElement {
  static properties = {
    msg: { type: String },
    counter: { type: Number },
  };

  constructor() {
    super();
    this.msg = ' ';
    this.counter = 0;
  }

  updated(changedProperties) {
    super.updated(changedProperties);
    if (i < fullText.length) {
      setTimeout(() => {
        this.msg += fullText[i];
        i += 1;
      }, Math.floor(Math.random() * 50) + 40);
    }
  }

  render() {
    return html`
      <p>ğŸ¤” Hello <span>${this.msg}</span>${'ğŸ¤¯'.repeat(this.counter)}</p>
      <button @click=${this._inc}>+</button>
    `;
  }

  _inc() {
    if (i >= fullText.length) {
      this.counter += 1;
    }
  }

  static styles = [
    css`
      button {
        font-size: 200%;
        width: 64px;
        height: 64px;
        border: none;
        border-radius: 10px;
        background-color: seagreen;
        color: white;
      }
    `,
  ];
}
```

---

Now if we add this to our page we get...

âœ… our component rendered
âŒ ...with no typing effect
âŒ ...and with a button that is not doing anything

ğŸ‘‰ `site/pages/index.rocket.js`

```js
export async function registerCustomElements() {
  // server-only components
  // prettier-ignore
  customElements.define('hello-wave', await import('my-pkg/site/src/components/HelloWave.js').then(m => m.HelloWave));
  // prettier-ignore
  customElements.define('hello-typer', await import('my-pkg/site/src/components/HelloTyper.js').then(m => m.HelloTyper));
}

export default () => html`
  <h1>Hello World</h1>
  <hello-wave></hello-wave>
  <hello-typer></hello-typer>
`;
```

![Typer Static](./typer-static.png)

---

We get this because our component is now more than "just" text.
It now has interactive functionality.

Which means that if we only send HTML & CSS to the browser it will not be enough.

---

We can now decide to skip the server render and render the component purely client side.

We can do that by putting `loading="client"` on the component.

```js
export async function registerCustomElements() {
  // server-only components
  // prettier-ignore
  customElements.define('hello-wave', await import('my-pkg/site/src/components/HelloWave.js').then(m => m.HelloWave));
  // client-only components
  // 'hello-typer': () => import('my-pkg/site/src/components/HelloTyper.js').then(m => m.HelloTyper),
}

export default () => html`
  <h1>Hello World</h1>
  <hello-wave></hello-wave>
  <hello-typer loading="client"></hello-typer>
`;
```

---

This however has a few downsides:

â¡ï¸ component does not get rendered initially but only after loading is done
â¡ï¸ brings a layout shift
â¡ï¸ delays initial render
â¡ï¸ requires search engines to execute JS to see the content (some do, some don't)

<video src="./typer-client.mp4"></video>

---

Or we do âœ¨ Progressive Hydration âœ¨

Progressive stands for?

â¡ï¸ Start with 0 JavaScript of components
â¡ï¸ Load components as needed

---

Hydrations stands for?

1ï¸âƒ£ Server render (ships HTML with Declarative Shadow Dom)
2ï¸âƒ£ Client loads the components JS Code (as needed)
3ï¸âƒ£ Rerender the component (sync DOM/JS - no change)
4ï¸âƒ£ Now the component can be interacted with

---

To enable hydration we put `loading="hydrate:onVisible"` on the component.

```js
export async function registerCustomElements() {
  // server-only components
  // prettier-ignore
  customElements.define('hello-wave', await import('my-pkg/site/src/components/HelloWave.js').then(m => m.HelloWave));
  // hydrate-able components
  // prettier-ignore
  customElements.define('hello-typer', await import('my-pkg/site/src/components/HelloTyper.js').then(m => m.HelloTyper));
}

export default () => html`
  <h1>Hello World</h1>
  <hello-wave></hello-wave>
  <hello-typer loading="hydrate:onVisible"></hello-typer>
`;
```

---

By hydrating our component as soon as it becomes visible we get

â¡ï¸ component getting rendered as static content
â¡ï¸ no layout shift or delayed render
â¡ï¸ interactive components as loading conditions are met

<video src="./typer-hydration.mp4"></video>

---

There are multiple conditions you can combine to get the best loading strategy for your use case:
â¡ï¸ media query (screen size, reduced motion, ...)
â¡ï¸ client load
â¡ï¸ click
â¡ï¸ visible
â¡ï¸ idle
â¡ï¸ ...

```html
<h1>Rocket Blog</h1>
<inline-notification>Do this</inline-notification>
<!-- ğŸ‘† will be only server rendered -->

<my-hero loading="hydrate:onClientLoad">
  Welcome ...
</my-hero>
<!-- ğŸ‘† server render + hydrate as soon as possible -->

<my-list loading="hydrate"></my-list>
<!-- ğŸ‘† server render + hydrate if main thread is idle  -->

<my-chart loading="hydrate:onVisible"></my-chart>
<!-- ğŸ‘† server render + hydrate as element becomes visible  -->

<my-heavy-chart loading="onVisible || onMedia('(min-width: 768px)')"></my-heavy-chart>
<!-- ğŸ‘† server render + hydrate -->
<!-- desktop: hydrate immediately (matches media query) -->
<!-- mobile: hydrate as element becomes visible -->

<my-heavy-graph loading="hydrate:onMedia('(min-width: 768px)') && onVisible || onClick"></my-heavy-graph>
<!-- ğŸ‘† server render + hydrate -->
<!-- desktop: hydrate as element becomes visible -->
<!-- mobile: hydrate on click (to safe bandwidth) -->

<my-login loading="client"></m-login>
<!-- ğŸ‘† only client render -->
```

---

With that we should have all the stepping stones to build

ğŸƒâ€â™‚ï¸ Fast
ğŸ”» Small (as we start with next to 0 JS)
ğŸ’ª No Magic

websites ğŸ‰

Go check it out

https://next.rocket.modern-web.dev/docs/basics/hydration/

---

Or try it for yourself ğŸ’ª

ğŸ‘¨â€ğŸ’» `npx @rocket/create@latest`

and select the "Hydration Starter"

There is also a production deployment of this example

https://rocket-hydration-starter.netlify.app/

```
npx @rocket/create@latest
        |          Welcome to Rocket! (Â®rocket/create v0.0.7)
       / \         Everyone can code a website
      / _ \
     |.o '.|       You are about to embark upon a new mission ğŸš€.
     |'._.'|
     |     |
   ,'|  |  |`.
  /  |  |  |  \    If you encounter a problem, visit
  |,-'--|--'-.|      https://github.com/modernweb-dev/rocket/issues
      ( | )        to search or file a new issue
     ((   ))
    ((  :  ))      Follow us: https://twitter.com/modern_web_dev
     ((   ))       Chat with us: https://next.rocket.modern-web.dev/chat
      (( ))
       ( )         Notes: You can exit any time with Ctrl+C or Esc
        .                 A new folder "rocket-<template name>" will be created
        .

? Which Starter Template would you like to use? â€º - Use arrow-keys. Return to submit.
â¯   Hydration Starter - Example on how to hydrate web components
    Blog Starter
    Minimal Starter
    Sanity Minimal Starter
    Landing Page (Spark Theme)
    Custom (community built)
```

---

If you wanna know more what Rocket is then be sure to check out the initial release thread

https://twitter.com/daKmoR/status/1506601983293235209?s=20&t=ujwk5xxUu89jqTALfX9PzA

---

If you have any questions or are interested in topics like

â¡ï¸ Web Standards
â¡ï¸ Template Literals
â¡ï¸ Web Components
â¡ï¸ Hydration
â¡ï¸ Static Site Generator (SSG)
â¡ï¸ ...

then you should join our Discord Community ğŸ¤—

https://discord.gg/sTdpM2rkKJ
